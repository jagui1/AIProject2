
# coding: utf-8

# In[363]:

import matplotlib.pyplot as plt
import numpy as np

X_MIN = -2.5
X_MAX = 2.5
Y_MIN = -2.5
Y_MAX = 2.5
STEP = .05
RESTARTS = 100
MAX_TEMP = 1000

def main():
    '''
    print("Test function: sinc(x) + sinc(y)")
    localMin, xVal, yVal = hill_climb(sincFn, STEP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Basic Hillclimbing \nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = hill_climb_random_restart(sincFn, STEP, RESTARTS, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Hillclimbing with restarts\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    simulated_annealing(sincFn, STEP, MAX_TEMP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Simulated Annealing\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
  

    print("Test function: tan(x) * tan(y)")
    localMin, xVal, yVal = hill_climb(tantan, STEP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Basic Hillclimbing \nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = hill_climb_random_restart(tantan, STEP, RESTARTS, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Hillclimbing with restarts\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = simulated_annealing(tantan, STEP, MAX_TEMP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Simulated Annealing\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    

    print("Test function: x * y")
    localMin, xVal, yVal = hill_climb(xTimesY, STEP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Basic Hillclimbing \nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = hill_climb_random_restart(xTimesY, STEP, RESTARTS, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Hillclimbing with restarts\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = simulated_annealing(xTimesY, STEP, MAX_TEMP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Simulated Annealing\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    '''
    print("Test function: long one")
    localMin, xVal, yVal = hill_climb(realFn, STEP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Basic Hillclimbing \nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = hill_climb_random_restart(realFn, STEP, RESTARTS, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Hillclimbing with restarts\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)
    localMin, xVal, yVal = simulated_annealing(realFn, STEP, MAX_TEMP, X_MIN, X_MAX, Y_MIN, Y_MAX)
    print("Simulated Annealing\nlocalMIN:",localMin, "x:",xVal,"y:",yVal)


# In[364]:

def hill_climb(function_to_optimize, step_size, xmin, xmax, ymin, ymax):
    curX = np.random.uniform( xmin, xmax )
    curY = np.random.uniform( ymin, ymax )
    curMin = function_to_optimize(curX, curY)
    searching = True

    while(searching):
        #print("curMIN:",curMin, "x:",curX,"y:",curY)
        
        tempMin = [function_to_optimize(curX+step_size, curY), function_to_optimize(curX-step_size, curY), function_to_optimize(curX, curY+step_size), function_to_optimize(curX, curY-step_size)]
        
        if( curX+step_size <= xmax and tempMin[0] < curMin ):
            curX = curX + step_size
            curMin = function_to_optimize(curX, curY)
        elif( curX-step_size >= xmin and tempMin[1] < curMin ):
            curX = curX - step_size
            curMin = function_to_optimize(curX, curY)
        elif( curY+step_size <= ymax and tempMin[2] < curMin ):
            curY = curY + step_size
            curMin = function_to_optimize(curX, curY)
        elif( curY-step_size >= ymin and tempMin[3] < curMin ):
            curY = curY - step_size
            curMin = function_to_optimize(curX, curY)
        else:
            #print("Local min or plateau or something\ncurMin",curMin,"\ntempmins", tempMin)
            searching = False

    #print("end loop - min:",curMin)
    #print("localMin:",curMin, "x:",curX,"y:",curY)
    return curMin, curX, curY


# In[365]:

def hill_climb_random_restart(function_to_optimize, step_size, num_restarts, xmin, xmax, ymin, ymax):
    curMin, curX, curY = hill_climb(function_to_optimize, step_size, xmin, xmax, ymin, ymax)
    
    for i in range(num_restarts - 1):
        tempMin, xVal, yVal = hill_climb(function_to_optimize, step_size, xmin, xmax, ymin, ymax)
        
        #print("tempMin:",tempMin, "curMin: ",curMin,"x:",xVal,"y:",yVal)
        
        if tempMin < curMin:
            #print("updating curmin")
            curMin = tempMin
            curX = xVal
            curY = yVal
            
    return curMin, curX, curY


# In[366]:

def simulated_annealing(function_to_optimize, step_size, max_temp, xmin, xmax, ymin, ymax):
    
    COOLING = .90
    
    def probability(prev, cur, temp):
        return np.exp( (prev - cur)/temp )
    
    curX = np.random.uniform( xmin, xmax )
    curY = np.random.uniform( ymin, ymax )
    xVal = curX
    yVal = curY
    curMin = function_to_optimize(curX, curY)
    
    #print("Starting SA\nlocalMin:",curMin, "x:",curX,"y:",curY)

    while( max_temp >= .0001):
        tempMin = [function_to_optimize(curX+step_size, curY), function_to_optimize(curX-step_size, curY), function_to_optimize(curX, curY+step_size), function_to_optimize(curX, curY-step_size)]
        legalChange = [curX+step_size <= xmax, curX-step_size >= xmin, curY+step_size <= ymax, curY-step_size >= ymin]
        tempChange = [curX+step_size, curX-step_size, curY+step_size, curY-step_size]
        direction = np.random.randint(4)
        
        if( legalChange[direction] and tempMin[direction] < curMin ):
            if direction in [0,1]:
                curX = tempChange[direction]
            elif direction in [2,3]:
                curY = tempChange[direction]
            #print("updating min - tempMin:",tempMin[direction],"curMin", curMin,"temp",max_temp)

            curMin = function_to_optimize(curX, curY)
            xVal = curX
            yVal = curY
            
        else:
            prob = probability(curMin, tempMin[direction], max_temp)
            randNum = np.random.random()
            if prob > randNum:
                if direction in [0,1]:
                    curX = tempChange[direction]
                elif direction in [2,3]:
                    curY = tempChange[direction]       
                #print("making bad move - tempMin:",tempMin[direction],"curMin", curMin,"probability", prob, "random", randNum,"temp",max_temp)

        max_temp *= COOLING
    
    return curMin, xVal, yVal
        


# In[367]:

def sincFn(x,y):
    if type(x) in [int, float] and type(y) in [int, float]:
        return float( np.sinc(x) + np.sinc(y) )
    else:
        return False


# In[368]:

def tantan(x,y):
    if type(x) in [int, float] and type(y) in [int, float]:
        return float( np.tan(x) * np.tan(y) )
    else:
        return False


# In[369]:

def xTimesY(x,y):
    if type(x) in [int, float] and type(y) in [int, float]:
        return float( x * y )
    else:
        return False


# In[370]:

def realFn(x,y):
    if type(x) in [int, float] and type(y) in [int, float]:
        r = np.sqrt(x**2 + y**2)
        return ( np.sin(x**2 + 3*(y**2))/(.1 + r**2) ) + (x**2 + 5*(y**2)) * ( np.exp(1-r**2)/2 )
    else:
        return False


# In[371]:

main()

